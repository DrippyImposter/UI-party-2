--[[
    Modern UI Library - ENHANCED VERSION
    A comprehensive UI library for Roblox with support for:
    - Tabs
    - Buttons (normal, toggleable, one-time action) with setText
    - Info containers
    - Sliders (with decimal support and custom labels)
    - Textboxes
    - Dropdowns (small, positioned properly) with setText
    - And more!
    
    NEW FEATURES:
    - setText() support for: Buttons, Sliders, Action Toggles, Toggles, Type Switchers, Dropdowns
    - Decimal support for sliders (config.decimals)
    - Custom text labels for sliders (config.labels) - optional
]]

local UILibrary = {}
UILibrary.__index = UILibrary

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local Player = Players.LocalPlayer

-- Default theme
local defaultTheme = {
    background = Color3.fromRGB(10, 10, 10),
    surface = Color3.fromRGB(20, 20, 20),
    accent = Color3.fromRGB(0, 255, 136),
    accent2 = Color3.fromRGB(0, 200, 255),
    text = Color3.fromRGB(220, 220, 220),
    glow = Color3.fromRGB(0, 255, 136),
    slider = Color3.fromRGB(40, 40, 40),
    sliderFill = Color3.fromRGB(0, 255, 136),
    toggleOff = Color3.fromRGB(255, 50, 50),
    toggleOn = Color3.fromRGB(0, 255, 100),
    dropdown = Color3.fromRGB(30, 30, 30),
    dropdownHover = Color3.fromRGB(40, 40, 40),
    success = Color3.fromRGB(120, 220, 150),
    error = Color3.fromRGB(255, 120, 120),
    warning = Color3.fromRGB(255, 200, 100),
    highlight = Color3.fromRGB(255, 255, 255)
}

-- Utility Functions
local function createHoverEffect(button, originalColor)
    local hoverColor = originalColor:Lerp(Color3.fromRGB(255, 255, 255), 0.06)
    
    button.MouseEnter:Connect(function()
        button.BackgroundColor3 = hoverColor
    end)
    
    button.MouseLeave:Connect(function()
        button.BackgroundColor3 = originalColor
    end)
end

local function updateCheckboxAppearance(checkbox, isEnabled, theme)
    if isEnabled then
        checkbox.Text = "✓"
        checkbox.TextColor3 = theme.background
        checkbox.TextScaled = true
        checkbox.BackgroundColor3 = theme.toggleOn
        checkbox.BorderColor3 = theme.toggleOn
    else
        checkbox.Text = ""
        checkbox.TextColor3 = theme.toggleOn
        checkbox.BackgroundColor3 = theme.dropdown
        checkbox.BorderColor3 = theme.accent
    end
end

-- Main Window Creation
function UILibrary.new(config)
    local self = setmetatable({}, UILibrary)
    
    config = config or {}
    self.title = config.title or "UI Library"
    self.theme = config.theme or defaultTheme
    self.size = config.size or UDim2.new(0, 400, 0, 620)
    self.position = config.position or UDim2.new(0.5, -200, 0.5, -310)
    self.toggleKey = config.toggleKey or Enum.KeyCode.H
    
    -- Check if mobile
    self.isMobile = UserInputService.TouchEnabled
    if self.isMobile then
        self.size = UDim2.new(0, 340, 0, 560)
        self.position = UDim2.new(0.5, -170, 0.5, -280)
    end
    
    self.tabs = {}
    self.currentTab = nil
    
    self:_createBase()
    self:_setupDragging()
    self:_setupToggle()
    
    return self
end

function UILibrary:_createBase()
    -- Remove existing GUI
    local existingGui = Player.PlayerGui:FindFirstChild("UILibraryGUI")
    if existingGui then
        existingGui:Destroy()
    end
    
    -- ScreenGui
    self.screenGui = Instance.new("ScreenGui")
    self.screenGui.Name = "UILibraryGUI"
    self.screenGui.ResetOnSpawn = false
    self.screenGui.Parent = Player.PlayerGui
    
    -- Main frame
    self.frame = Instance.new("Frame")
    self.frame.Size = self.size
    self.frame.Position = self.position
    self.frame.BackgroundColor3 = self.theme.background
    self.frame.BorderSizePixel = 0
    self.frame.ClipsDescendants = true
    self.frame.Parent = self.screenGui
    
    -- Glow
    self.glow = Instance.new("Frame")
    self.glow.Size = UDim2.new(1, 10, 1, 10)
    self.glow.Position = UDim2.new(0, -5, 0, -5)
    self.glow.BackgroundColor3 = self.theme.glow
    self.glow.BackgroundTransparency = 0.8
    self.glow.BorderSizePixel = 0
    self.glow.ZIndex = -1
    self.glow.Parent = self.frame
    
    local glowCorner = Instance.new("UICorner")
    glowCorner.CornerRadius = UDim.new(0, 6)
    glowCorner.Parent = self.glow
    
    -- Inner border
    self.innerBorder = Instance.new("Frame")
    self.innerBorder.Size = UDim2.new(1, -4, 1, -4)
    self.innerBorder.Position = UDim2.new(0, 2, 0, 2)
    self.innerBorder.BackgroundColor3 = self.theme.surface
    self.innerBorder.BorderSizePixel = 0
    self.innerBorder.Parent = self.frame
    
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 4)
    frameCorner.Parent = self.innerBorder
    
    -- Title bar
    self.titleBar = Instance.new("Frame")
    self.titleBar.Size = UDim2.new(1, 0, 0, 35)
    self.titleBar.Position = UDim2.new(0, 0, 0, 0)
    self.titleBar.BackgroundColor3 = self.theme.surface
    self.titleBar.BorderSizePixel = 0
    self.titleBar.Parent = self.innerBorder
    
    -- Title text
    self.titleLabel = Instance.new("TextLabel")
    self.titleLabel.Size = UDim2.new(1, -40, 1, 0)
    self.titleLabel.Position = UDim2.new(0, 10, 0, 0)
    self.titleLabel.BackgroundTransparency = 1
    self.titleLabel.Text = self.title
    self.titleLabel.TextColor3 = self.theme.accent
    self.titleLabel.Font = Enum.Font.Code
    self.titleLabel.TextSize = 14
    self.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.titleLabel.TextStrokeTransparency = 0.8
    self.titleLabel.TextStrokeColor3 = self.theme.glow
    self.titleLabel.Parent = self.titleBar
    
    -- Status light
    self.statusLight = Instance.new("Frame")
    self.statusLight.Size = UDim2.new(0, 8, 0, 8)
    self.statusLight.Position = UDim2.new(1, -15, 0.5, -4)
    self.statusLight.BackgroundColor3 = self.theme.accent2
    self.statusLight.BorderSizePixel = 0
    self.statusLight.Parent = self.titleBar
    
    -- Tabs row
    self.tabsRow = Instance.new("ScrollingFrame")
    self.tabsRow.Size = UDim2.new(1, 0, 0, 30)
    self.tabsRow.Position = UDim2.new(0, 0, 0, 35)
    self.tabsRow.BackgroundTransparency = 1
    self.tabsRow.ScrollBarThickness = 0
    self.tabsRow.CanvasSize = UDim2.new(0, 0, 0, 30)
    self.tabsRow.ScrollingDirection = Enum.ScrollingDirection.X
    self.tabsRow.Parent = self.innerBorder
    
    -- Active indicator
    self.activeIndicator = Instance.new("Frame")
    self.activeIndicator.Name = "ActiveIndicator"
    self.activeIndicator.Size = UDim2.new(0, 83, 0, 3)
    self.activeIndicator.Position = UDim2.new(0, 6, 1, -3)
    self.activeIndicator.BackgroundColor3 = self.theme.accent2
    self.activeIndicator.BorderSizePixel = 0
    self.activeIndicator.ZIndex = 100
    self.activeIndicator.Parent = self.tabsRow
    
    local indicatorCorner = Instance.new("UICorner")
    indicatorCorner.CornerRadius = UDim.new(0, 2)
    indicatorCorner.Parent = self.activeIndicator
end

function UILibrary:_setupDragging()
    local dragging = false
    local dragInput = nil
    local dragStart = nil
    local startPos = nil
    
    local function update(input)
        local delta = input.Position - dragStart
        self.frame.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
    
    self.titleBar.Active = true
    
    self.titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = self.frame.Position
            dragInput = input
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    dragInput = nil
                end
            end)
        end
    end)
    
    self.titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if not dragging then return end
        if input == dragInput then
            update(input)
            return
        end
        if input.UserInputType == Enum.UserInputType.Touch then
            update(input)
        end
    end)
end

function UILibrary:_setupToggle()
    UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if gameProcessedEvent then return end
        if UserInputService:GetFocusedTextBox() then return end
        if input.UserInputType == Enum.UserInputType.Keyboard and 
           input.KeyCode == self.toggleKey then
            self.screenGui.Enabled = not self.screenGui.Enabled
        end
    end)
end

function UILibrary:_moveIndicatorTo(button, instant)
    local firstTabPos = self.tabs[1] and self.tabs[1].button.Position.X.Offset or 0
    local targetX = button.Position.X.Offset - firstTabPos
    local targetW = button.Size.X.Offset - 12
    
    local targetPos = UDim2.new(0, targetX + 6, 1, -3)
    local targetSize = UDim2.new(0, targetW, 0, 3)
    
    if instant then
        self.activeIndicator.Position = targetPos
        self.activeIndicator.Size = targetSize
        return
    end
    
    local info = TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local t1 = TweenService:Create(self.activeIndicator, info, {Position = targetPos})
    local t2 = TweenService:Create(self.activeIndicator, info, {Size = targetSize})
    t1:Play()
    t2:Play()
end

-- Tab Creation
function UILibrary:addTab(name)
    local tab = {}
    tab.name = name
    tab.elements = {}
    
    -- Create tab button
    local tabIndex = #self.tabs + 1
    local xPos = 6 + (tabIndex - 1) * 101
    
    tab.button = Instance.new("TextButton")
    tab.button.Size = UDim2.new(0, 95, 1, -6)
    tab.button.Position = UDim2.new(0, xPos, 0, 3)
    tab.button.BackgroundColor3 = self.theme.dropdown
    tab.button.BorderSizePixel = 0
    tab.button.Text = name
    tab.button.TextColor3 = self.theme.text
    tab.button.Font = Enum.Font.Code
    tab.button.TextSize = 12
    tab.button.Parent = self.tabsRow
    
    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 6)
    tabCorner.Parent = tab.button
    
    -- Create content frame
    tab.content = Instance.new("ScrollingFrame")
    tab.content.Size = UDim2.new(1, -20, 1, -60)
    tab.content.Position = UDim2.new(0, 10, 0, 70)
    tab.content.BackgroundTransparency = 1
    tab.content.ScrollBarThickness = 0
    tab.content.Parent = self.innerBorder
    tab.content.Visible = false
    
    -- Layout
    tab.layout = Instance.new("UIListLayout")
    tab.layout.SortOrder = Enum.SortOrder.LayoutOrder
    tab.layout.Padding = UDim.new(0, 6)
    tab.layout.Parent = tab.content
    
    -- Store base canvas size for this tab
    tab.baseCanvasHeight = 10
    
    -- Auto-resize canvas
    tab.content.CanvasSize = UDim2.new(0, 0, 0, 10)
    tab.layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        local h = tab.layout.AbsoluteContentSize.Y + 18
        tab.baseCanvasHeight = math.max(h, 200)
        tab.content.CanvasSize = UDim2.new(0, 0, 0, tab.baseCanvasHeight)
    end)
    
    -- Button click handler
    tab.button.MouseButton1Click:Connect(function()
        self:_selectTab(tab)
    end)
    
    -- Update canvas size for tabs
    self.tabsRow.CanvasSize = UDim2.new(0, xPos + 100, 0, 30)
    
    table.insert(self.tabs, tab)
    
    -- Select first tab
    if #self.tabs == 1 then
        self:_selectTab(tab)
    end
    
    return setmetatable(tab, {__index = self})
end

function UILibrary:_selectTab(tab)
    -- Hide all tabs
    for _, t in ipairs(self.tabs) do
        t.content.Visible = false
        t.button.BackgroundColor3 = self.theme.dropdown
        t.button.TextColor3 = self.theme.text
    end
    
    -- Show selected tab
    tab.content.Visible = true
    tab.button.BackgroundColor3 = self.theme.surface
    tab.button.TextColor3 = self.theme.accent2
    
    self.currentTab = tab
    self:_moveIndicatorTo(tab.button)
end

-- Button (NOW WITH setText)
function UILibrary:addButton(config)
    config = config or {}
    local text = config.text or "Button"
    local callback = config.callback or function() end
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 0, config.height or 40)
    button.BackgroundColor3 = self.theme.surface
    button.BorderColor3 = config.borderColor or self.theme.accent2
    button.BorderSizePixel = 2
    button.Text = text
    button.TextColor3 = config.textColor or self.theme.accent2
    button.Font = Enum.Font.Code
    button.TextSize = config.textSize or 12
    button.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    button.Parent = self.content
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = button
    
    createHoverEffect(button, self.theme.surface)
    
    button.MouseButton1Click:Connect(callback)
    
    table.insert(self.elements, {type = "button", element = button})
    
    -- Return API with setText
    return {
        setText = function(newText)
            button.Text = newText
        end,
        element = button
    }
end

-- Action Toggle (NOW WITH setText)
function UILibrary:addActionToggle(config)
    config = config or {}
    local text = config.text or "Action"
    local callback = config.callback or function() end
    
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, config.height or 30)
    row.BackgroundTransparency = 1
    row.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    row.Parent = self.content
    
    local checkbox = Instance.new("TextButton")
    checkbox.Size = UDim2.new(0, 24, 0, 24)
    checkbox.Position = UDim2.new(0, 4, 0, 3)
    checkbox.BackgroundColor3 = self.theme.dropdown
    checkbox.BorderColor3 = self.theme.accent
    checkbox.BorderSizePixel = 1
    checkbox.Text = ""
    checkbox.Font = Enum.Font.Code
    checkbox.TextSize = 16
    checkbox.TextScaled = true
    checkbox.TextColor3 = self.theme.toggleOn
    checkbox.Parent = row
    
    local checkCorner = Instance.new("UICorner")
    checkCorner.CornerRadius = UDim.new(0, 4)
    checkCorner.Parent = checkbox
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -32, 1, 0)
    label.Position = UDim2.new(0, 32, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = self.theme.text
    label.Font = Enum.Font.Code
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = row
    
    -- Keep checkbox in "off" state (grey)
    updateCheckboxAppearance(checkbox, false, self.theme)
    
    -- Store original colors
    local originalBg = checkbox.BackgroundColor3
    local originalBorder = checkbox.BorderColor3
    
    checkbox.MouseButton1Click:Connect(function()
        -- Flash green animation (1 second)
        task.spawn(function()
            -- Turn green
            checkbox.BackgroundColor3 = self.theme.toggleOn
            checkbox.BorderColor3 = self.theme.toggleOn
            checkbox.Text = "✓"
            checkbox.TextColor3 = self.theme.background
            checkbox.TextScaled = true
            
            task.wait(1)
            
            -- Revert to grey/off state
            checkbox.BackgroundColor3 = originalBg
            checkbox.BorderColor3 = originalBorder
            checkbox.Text = ""
            checkbox.TextColor3 = self.theme.toggleOn
        end)
        
        -- Execute callback
        callback()
    end)
    
    createHoverEffect(checkbox, checkbox.BackgroundColor3)
    
    table.insert(self.elements, {type = "actiontoggle", element = row, checkbox = checkbox})
    
    -- Return API with setText
    return {
        setText = function(newText)
            label.Text = newText
        end,
        element = row
    }
end

-- Toggle Button (NOW WITH setText)
function UILibrary:addToggle(config)
    config = config or {}
    local text = config.text or "Toggle"
    local default = config.default or false
    local callback = config.callback or function() end
    
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, config.height or 30)
    row.BackgroundTransparency = 1
    row.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    row.Parent = self.content
    
    local checkbox = Instance.new("TextButton")
    checkbox.Size = UDim2.new(0, 24, 0, 24)
    checkbox.Position = UDim2.new(0, 4, 0, 3)
    checkbox.BackgroundColor3 = self.theme.dropdown
    checkbox.BorderColor3 = self.theme.accent
    checkbox.BorderSizePixel = 1
    checkbox.Text = ""
    checkbox.Font = Enum.Font.Code
    checkbox.TextSize = 16
    checkbox.TextScaled = true
    checkbox.TextColor3 = self.theme.toggleOn
    checkbox.Parent = row
    
    local checkCorner = Instance.new("UICorner")
    checkCorner.CornerRadius = UDim.new(0, 4)
    checkCorner.Parent = checkbox
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -32, 1, 0)
    label.Position = UDim2.new(0, 32, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = self.theme.text
    label.Font = Enum.Font.Code
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = row
    
    local state = default
    updateCheckboxAppearance(checkbox, state, self.theme)
    
    checkbox.MouseButton1Click:Connect(function()
        state = not state
        updateCheckboxAppearance(checkbox, state, self.theme)
        callback(state)
    end)
    
    createHoverEffect(checkbox, checkbox.BackgroundColor3)
    
    table.insert(self.elements, {type = "toggle", element = row, checkbox = checkbox})
    return {
        setState = function(newState)
            state = newState
            updateCheckboxAppearance(checkbox, state, self.theme)
        end,
        getState = function()
            return state
        end,
        setText = function(newText)
            label.Text = newText
        end
    }
end

-- Type-Switching Button (NOW WITH setText)
function UILibrary:addTypeSwitcher(config)
    config = config or {}
    local types = config.types or {"Option 1", "Option 2"}
    local default = config.default or 1
    local callback = config.callback or function() end
    
    local currentIndex = default
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 0, config.height or 40)
    button.BackgroundColor3 = self.theme.surface
    button.BorderColor3 = self.theme.accent2
    button.BorderSizePixel = 2
    button.Text = types[currentIndex]
    button.TextColor3 = self.theme.accent2
    button.Font = Enum.Font.Code
    button.TextSize = 12
    button.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    button.Parent = self.content
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = button
    
    createHoverEffect(button, self.theme.surface)
    
    button.MouseButton1Click:Connect(function()
        currentIndex = (currentIndex % #types) + 1
        button.Text = types[currentIndex]
        callback(types[currentIndex], currentIndex)
    end)
    
    table.insert(self.elements, {type = "typeswitcher", element = button})
    return {
        setType = function(index)
            currentIndex = index
            button.Text = types[currentIndex]
        end,
        getCurrentType = function()
            return types[currentIndex], currentIndex
        end,
        setText = function(newText)
            button.Text = newText
        end
    }
end

-- Label
function UILibrary:addLabel(config)
    config = config or {}
    local text = config.text or "Label"
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, config.height or 20)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = config.textColor or self.theme.text
    label.Font = Enum.Font.Code
    label.TextSize = config.textSize or 12
    label.TextXAlignment = config.alignment or Enum.TextXAlignment.Left
    label.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    label.Parent = self.content
    
    table.insert(self.elements, {type = "label", element = label})
    return {
        setText = function(newText)
            label.Text = newText
        end
    }
end

-- Info Container
function UILibrary:addInfoContainer(config)
    config = config or {}
    local text = config.text or "Info"
    local infoColor = config.infoColor or self.theme.dropdown
    
    local container = Instance.new("TextLabel")
    container.Size = UDim2.new(1, 0, 0, config.height or 80)
    container.BackgroundColor3 = infoColor
    container.BorderColor3 = config.borderColor or self.theme.accent
    container.BorderSizePixel = 1
    container.Text = text
    container.TextColor3 = config.textColor or self.theme.text
    container.Font = Enum.Font.Code
    container.TextSize = config.textSize or 10
    container.TextYAlignment = Enum.TextYAlignment.Top
    container.TextXAlignment = Enum.TextXAlignment.Left
    container.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    container.Parent = self.content
    
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 10)
    padding.PaddingTop = UDim.new(0, 5)
    padding.Parent = container
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = container
    
    table.insert(self.elements, {type = "infocontainer", element = container})
    return {
        setText = function(newText)
            container.Text = newText
        end,
        setColor = function(newColor)
            container.BackgroundColor3 = newColor
        end
    }
end

-- Textbox
function UILibrary:addTextbox(config)
    config = config or {}
    local placeholder = config.placeholder or "Enter text..."
    local default = config.default or ""
    local callback = config.callback or function() end
    
    local textbox = Instance.new("TextBox")
    textbox.Size = UDim2.new(1, 0, 0, config.height or 35)
    textbox.BackgroundColor3 = self.theme.dropdown
    textbox.BorderColor3 = self.theme.accent
    textbox.BorderSizePixel = 1
    textbox.PlaceholderText = placeholder
    textbox.Text = default
    textbox.TextColor3 = self.theme.text
    textbox.Font = Enum.Font.Code
    textbox.TextSize = 12
    textbox.TextXAlignment = Enum.TextXAlignment.Left
    textbox.ClearTextOnFocus = config.clearOnFocus or false
    textbox.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    textbox.Parent = self.content
    
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 10)
    padding.Parent = textbox
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = textbox
    
    textbox.Focused:Connect(function()
        textbox.BorderColor3 = self.theme.accent2
    end)
    
    textbox.FocusLost:Connect(function(enter)
        textbox.BorderColor3 = self.theme.accent
        callback(textbox.Text, enter)
    end)
    
    table.insert(self.elements, {type = "textbox", element = textbox})
    return {
        getText = function()
            return textbox.Text
        end,
        setText = function(newText)
            textbox.Text = newText
        end
    }
end

-- Slider (NOW WITH DECIMALS AND CUSTOM LABELS!)
function UILibrary:addSlider(config)
    config = config or {}
    local min = config.min or 0
    local max = config.max or 100
    local default = config.default or 50
    local suffix = config.suffix or ""
    local decimals = config.decimals or 0  -- NEW: Decimal places (0 = integers)
    local labels = config.labels or nil    -- NEW: Custom labels {value, label} or nil
    local callback = config.callback or function() end
    local hideValue = config.hideValue or false  -- NEW: Hide the raw value display
    
    -- Helper function to format value with decimals
    local function formatValue(value)
        if decimals == 0 then
            return tostring(math.floor(value + 0.5))
        else
            local multiplier = 10 ^ decimals
            return string.format("%." .. decimals .. "f", math.floor(value * multiplier + 0.5) / multiplier)
        end
    end
    
    -- Helper function to get custom label based on value
    local function getCustomLabel(value)
        if not labels then return nil end
        
        -- labels format: {{value1, "Label1"}, {value2, "Label2"}, ...}
        -- Find the appropriate label based on value
        for i = 1, #labels do
            local threshold = labels[i][1]
            local labelText = labels[i][2]
            
            if i == #labels then
                -- Last label
                if value >= threshold then
                    return labelText
                end
            else
                -- Check if value is between this and next threshold
                local nextThreshold = labels[i + 1][1]
                if value >= threshold and value < nextThreshold then
                    return labelText
                end
            end
        end
        
        -- Fallback to first label if below all thresholds
        return labels[1][2]
    end
    
    local labelText = config.text or "Slider"
    
    -- Label
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 20)
    label.BackgroundTransparency = 1
    
    -- Set initial label text
    if hideValue then
        -- Don't show any value, just the label text
        label.Text = labelText
    elseif labels then
        local customLabel = getCustomLabel(default)
        label.Text = labelText .. ": " .. customLabel .. " (" .. formatValue(default) .. suffix .. ")"
    else
        label.Text = labelText .. ": " .. formatValue(default) .. suffix
    end
    
    label.TextColor3 = self.theme.text
    label.Font = Enum.Font.Code
    label.TextSize = 11
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    label.Parent = self.content
    
    -- Slider background
    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(1, 0, 0, 20)
    sliderBg.BackgroundColor3 = self.theme.slider
    sliderBg.BorderSizePixel = 0
    sliderBg.LayoutOrder = config.layoutOrder or (#self.elements + 2)
    sliderBg.Parent = self.content
    
    local bgCorner = Instance.new("UICorner")
    bgCorner.CornerRadius = UDim.new(0, 4)
    bgCorner.Parent = sliderBg
    
    -- Slider fill
    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    sliderFill.Position = UDim2.new(0, 0, 0, 0)
    sliderFill.BackgroundColor3 = self.theme.sliderFill
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBg
    
    local fillCorner = Instance.new("UICorner")
    fillCorner.CornerRadius = UDim.new(0, 4)
    fillCorner.Parent = sliderFill
    
    -- Slider button (invisible)
    local sliderButton = Instance.new("TextButton")
    sliderButton.Size = UDim2.new(1, 0, 1, 0)
    sliderButton.Active = true
    sliderButton.Position = UDim2.new(0, 0, 0, 0)
    sliderButton.BackgroundTransparency = 1
    sliderButton.Text = ""
    sliderButton.Parent = sliderBg
    
    local currentValue = default
    local dragging = false
    
    local function updateSlider(percentage)
        percentage = math.clamp(percentage, 0, 1)
        sliderFill.Size = UDim2.new(percentage, 0, 1, 0)
        
        -- Calculate value with decimals
        if decimals == 0 then
            currentValue = math.floor(min + percentage * (max - min) + 0.5)
        else
            local multiplier = 10 ^ decimals
            currentValue = math.floor((min + percentage * (max - min)) * multiplier + 0.5) / multiplier
        end
        
        -- Update label with custom labels or regular format (only if not hideValue)
        if not hideValue then
            if labels then
                local customLabel = getCustomLabel(currentValue)
                label.Text = labelText .. ": " .. customLabel .. " (" .. formatValue(currentValue) .. suffix .. ")"
            else
                label.Text = labelText .. ": " .. formatValue(currentValue) .. suffix
            end
        end
        
        callback(currentValue, percentage)
    end
    
    sliderButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            
            local function update(posX)
                local x = posX or UserInputService:GetMouseLocation().X
                local sliderPos = sliderBg.AbsolutePosition.X
                local sliderSize = sliderBg.AbsoluteSize.X
                local percentage = math.clamp((x - sliderPos) / sliderSize, 0, 1)
                updateSlider(percentage)
            end
            
            if input.Position and input.UserInputType == Enum.UserInputType.Touch then
                update(input.Position.X)
            else
                update()
            end
            
            local connection
            connection = UserInputService.InputChanged:Connect(function(input2)
                if not dragging then return end
                if input2.UserInputType == Enum.UserInputType.MouseMovement then
                    update()
                elseif input2.UserInputType == Enum.UserInputType.Touch then
                    if input2.Position then update(input2.Position.X) end
                end
            end)
            
            local endConnection
            endConnection = UserInputService.InputEnded:Connect(function(input2)
                if input2.UserInputType == Enum.UserInputType.MouseButton1 or 
                   input2.UserInputType == Enum.UserInputType.Touch then
                    dragging = false
                    connection:Disconnect()
                    endConnection:Disconnect()
                end
            end)
        end
    end)
    
    table.insert(self.elements, {type = "slider", element = sliderBg, label = label})
    return {
        setValue = function(value)
            local percentage = (value - min) / (max - min)
            updateSlider(percentage)
        end,
        getValue = function()
            return currentValue
        end,
        setText = function(newText)
            -- Directly set the label text (for full custom control)
            label.Text = newText
        end,
        setLabelText = function(newLabelText)
            -- Update just the label part (before the colon)
            labelText = newLabelText
            -- Re-render with current value
            if hideValue then
                label.Text = labelText
            elseif labels then
                local customLabel = getCustomLabel(currentValue)
                label.Text = labelText .. ": " .. customLabel .. " (" .. formatValue(currentValue) .. suffix .. ")"
            else
                label.Text = labelText .. ": " .. formatValue(currentValue) .. suffix
            end
        end
    }
end

-- Dropdown (NOW WITH setText)
function UILibrary:addDropdown(config)
    config = config or {}
    local options = config.options or {"Option 1", "Option 2"}
    local default = config.default or options[1]
    local callback = config.callback or function() end
    
    -- Container row for label and dropdown
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, config.height or 26)
    row.BackgroundTransparency = 1
    row.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    row.Parent = self.content
    
    local dropdownLabel = nil
    
    -- Label (if provided)
    if config.label then
        dropdownLabel = Instance.new("TextLabel")
        dropdownLabel.Size = UDim2.new(0.5, 0, 1, 0)
        dropdownLabel.BackgroundTransparency = 1
        dropdownLabel.Text = config.label
        dropdownLabel.TextColor3 = self.theme.text
        dropdownLabel.Font = Enum.Font.Code
        dropdownLabel.TextSize = 12
        dropdownLabel.TextXAlignment = Enum.TextXAlignment.Left
        dropdownLabel.Parent = row
    end
    
    -- Dropdown button (SMALL - only takes up right side or specified width)
    local dropdownWidth = config.width or 0.48
    local dropdownPosition = config.position or 0.52
    
    local dropdown = Instance.new("TextButton")
    dropdown.Size = UDim2.new(dropdownWidth, 0, 1, 0)
    dropdown.Position = UDim2.new(dropdownPosition, 0, 0, 0)
    dropdown.BackgroundColor3 = self.theme.dropdown
    dropdown.BorderColor3 = self.theme.accent
    dropdown.BorderSizePixel = 1
    dropdown.Text = default
    dropdown.TextColor3 = self.theme.text
    dropdown.Font = Enum.Font.Code
    dropdown.TextSize = 12
    dropdown.Parent = row
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = dropdown
    
    -- Dropdown menu
    local menu = Instance.new("Frame")
    menu.Size = UDim2.new(1, 0, 0, 0)
    menu.Position = UDim2.new(0, 0, 1, 6)
    menu.BackgroundColor3 = self.theme.surface
    menu.BorderColor3 = self.theme.accent2
    menu.BorderSizePixel = 1
    menu.Visible = false
    menu.ZIndex = 100
    menu.Parent = dropdown
    
    local menuLayout = Instance.new("UIListLayout")
    menuLayout.Padding = UDim.new(0, 4)
    menuLayout.Parent = menu
    
    -- Create option buttons
    local currentOption = default
    for i, option in ipairs(options) do
        local optionBtn = Instance.new("TextButton")
        optionBtn.Size = UDim2.new(1, -10, 0, 24)
        optionBtn.Position = UDim2.new(0, 5, 0, 0)
        optionBtn.BackgroundColor3 = self.theme.surface
        optionBtn.BorderSizePixel = 0
        optionBtn.Text = option
        optionBtn.TextColor3 = self.theme.text
        optionBtn.Font = Enum.Font.Code
        optionBtn.TextSize = 12
        optionBtn.ZIndex = 101
        optionBtn.Parent = menu
        
        optionBtn.MouseButton1Click:Connect(function()
            currentOption = option
            dropdown.Text = option
            menu.Visible = false
            
            -- Restore canvas size when option is selected
            local tab = self.currentTab or self
            if tab and tab.baseCanvasHeight then
                tab.content.CanvasSize = UDim2.new(0, 0, 0, tab.baseCanvasHeight)
            end
            
            callback(option)
        end)
        
        createHoverEffect(optionBtn, self.theme.surface)
    end
    
    -- Resize menu based on content
    menuLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        local h = menuLayout.AbsoluteContentSize.Y + 8
        menu.Size = UDim2.new(1, 0, 0, h)
    end)
    
    -- SMART canvas resizing: Only expand if dropdown would overflow
    dropdown.MouseButton1Click:Connect(function()
        menu.Visible = not menu.Visible
        
        local tab = self.currentTab or self
        if not tab or not tab.content then return end
        
        if menu.Visible then
            task.wait()
            
            local menuHeight = menu.AbsoluteSize.Y
            local baseHeight = tab.baseCanvasHeight or 200
            
            -- Calculate if dropdown would overflow
            local dropdownBottomPos = dropdown.AbsolutePosition.Y + dropdown.AbsoluteSize.Y + menuHeight
            local contentBottomPos = tab.content.AbsolutePosition.Y + tab.content.AbsoluteSize.Y
            
            -- Only expand if dropdown would go beyond visible area
            if dropdownBottomPos > contentBottomPos then
                local extraSpace = dropdownBottomPos - contentBottomPos + 24
                tab.content.CanvasSize = UDim2.new(0, 0, 0, baseHeight + extraSpace)
                
                -- Scroll to show dropdown
                local dropdownRelativePos = dropdown.AbsolutePosition.Y - tab.content.AbsolutePosition.Y
                local scrollTarget = math.max(0, dropdownRelativePos - 20)
                tab.content.CanvasPosition = Vector2.new(0, scrollTarget)
            end
        else
            -- Restore original canvas size when dropdown closes
            local baseHeight = tab.baseCanvasHeight or 200
            tab.content.CanvasSize = UDim2.new(0, 0, 0, baseHeight)
        end
    end)
    
    table.insert(self.elements, {type = "dropdown", element = row, dropdown = dropdown, menu = menu})
    return {
        setOption = function(option)
            currentOption = option
            dropdown.Text = option
        end,
        getOption = function()
            return currentOption
        end,
        setText = function(newText)
            if dropdownLabel then
                dropdownLabel.Text = newText
            end
        end
    }
end

-- Divider
function UILibrary:addDivider(config)
    config = config or {}
    
    local divider = Instance.new("Frame")
    divider.Size = UDim2.new(1, -20, 0, config.height or 1)
    divider.BackgroundColor3 = config.color or Color3.fromRGB(255, 255, 255)
    divider.BackgroundTransparency = config.transparency or 0.8
    divider.BorderSizePixel = 0
    divider.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    divider.Parent = self.content
    
    table.insert(self.elements, {type = "divider", element = divider})
    return divider
end

-- Button Row (multiple buttons side-by-side)
function UILibrary:addButtonRow(config)
    config = config or {}
    local buttons = config.buttons or {}
    
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, config.height or 36)
    row.BackgroundTransparency = 1
    row.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    row.Parent = self.content
    
    local buttonWidth = 1 / #buttons
    local spacing = 0.02
    
    local createdButtons = {}
    for i, btnConfig in ipairs(buttons) do
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(buttonWidth - spacing, 0, 1, 0)
        btn.Position = UDim2.new((i-1) * buttonWidth + (spacing/2), 0, 0, 0)
        btn.BackgroundColor3 = self.theme.surface
        btn.BorderColor3 = btnConfig.borderColor or self.theme.accent
        btn.BorderSizePixel = 2
        btn.Text = btnConfig.text or "Button"
        btn.TextColor3 = btnConfig.textColor or self.theme.accent
        btn.Font = Enum.Font.Code
        btn.TextSize = btnConfig.textSize or 11
        btn.Parent = row
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = btn
        
        createHoverEffect(btn, self.theme.surface)
        
        btn.MouseButton1Click:Connect(btnConfig.callback or function() end)
        
        table.insert(createdButtons, btn)
    end
    
    table.insert(self.elements, {type = "buttonrow", element = row, buttons = createdButtons})
    return createdButtons
end

-- Move Button Grid (M1, M2, M3, M4 style)
function UILibrary:addMoveButtons(config)
    config = config or {}
    local callback = config.callback or function() end
    local selectedMove = config.default or 1
    
    -- Label
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 20)
    label.BackgroundTransparency = 1
    label.Text = config.text or "SELECT MOVE"
    label.TextColor3 = self.theme.text
    label.Font = Enum.Font.Code
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.LayoutOrder = config.layoutOrder or (#self.elements + 1)
    label.Parent = self.content
    
    -- Moves row
    local movesRow = Instance.new("Frame")
    movesRow.Size = UDim2.new(1, 0, 0, 50)
    movesRow.BackgroundTransparency = 1
    movesRow.LayoutOrder = config.layoutOrder or (#self.elements + 2)
    movesRow.Parent = self.content
    
    local moveButtons = {}
    
    for i = 1, 4 do
        local moveBtn = Instance.new("TextButton")
        moveBtn.Size = UDim2.new(0.23, 0, 1, 0)
        moveBtn.Position = UDim2.new((i-1) * 0.25 + 0.01, 0, 0, 0)
        moveBtn.BackgroundColor3 = self.theme.surface
        moveBtn.BorderColor3 = self.theme.accent
        moveBtn.BorderSizePixel = 2
        moveBtn.Text = "M" .. tostring(i)
        moveBtn.TextColor3 = self.theme.text
        moveBtn.Font = Enum.Font.Code
        moveBtn.TextSize = 18
        moveBtn.Parent = movesRow
        
        local moveCorner = Instance.new("UICorner")
        moveCorner.CornerRadius = UDim.new(0, 6)
        moveCorner.Parent = moveBtn
        
        moveButtons[i] = moveBtn
        
        moveBtn.MouseButton1Click:Connect(function()
            -- Deselect all
            for j = 1, 4 do
                moveButtons[j].BackgroundColor3 = self.theme.surface
                moveButtons[j].BorderColor3 = self.theme.accent
                moveButtons[j].TextColor3 = self.theme.text
            end
            
            -- Select this button
            moveBtn.BackgroundColor3 = self.theme.toggleOn
            moveBtn.BorderColor3 = self.theme.toggleOn
            moveBtn.TextColor3 = self.theme.background
            selectedMove = i
            
            callback(i)
        end)
        
        createHoverEffect(moveBtn, self.theme.surface)
    end
    
    -- Initialize selection
    moveButtons[selectedMove].BackgroundColor3 = self.theme.toggleOn
    moveButtons[selectedMove].BorderColor3 = self.theme.toggleOn
    moveButtons[selectedMove].TextColor3 = self.theme.background
    
    table.insert(self.elements, {type = "movebuttons", element = movesRow, buttons = moveButtons})
    return {
        setMove = function(move)
            -- Deselect all
            for j = 1, 4 do
                moveButtons[j].BackgroundColor3 = self.theme.surface
                moveButtons[j].BorderColor3 = self.theme.accent
                moveButtons[j].TextColor3 = self.theme.text
            end
            -- Select new
            moveButtons[move].BackgroundColor3 = self.theme.toggleOn
            moveButtons[move].BorderColor3 = self.theme.toggleOn
            moveButtons[move].TextColor3 = self.theme.background
            selectedMove = move
        end,
        getMove = function()
            return selectedMove
        end
    }
end

-- Status Light Control
function UILibrary:setStatusLight(color, animated)
    self.statusLight.BackgroundColor3 = color
    
    if animated then
        task.spawn(function()
            for i = 1, 10 do
                self.statusLight.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
                task.wait(0.15)
                self.statusLight.BackgroundColor3 = color
                task.wait(0.15)
            end
        end)
    end
end

-- Destroy
function UILibrary:destroy()
    if self.screenGui then
        self.screenGui:Destroy()
    end
end

return UILibrary

-- Below this Line is the example Usage for the UI Library

--[[
    USAGE EXAMPLES - Updated UI Library Features
    
    This file demonstrates all the NEW features added to the UI library:
    1. setText() support for Buttons, Sliders, Toggles, Action Toggles, Type Switchers, Dropdowns
    2. Decimal support for sliders
    3. Custom text labels for sliders (optional)
]]

local UILibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/DrippyImposter/UI-party-2/refs/heads/main/UI"))() -- Adjust path as needed

-- Create the main window
local ui = UILibrary.new({
    title = "Enhanced UI Library Demo",
    toggleKey = Enum.KeyCode.H
})

-- Create a tab
local tab = ui:addTab("Examples")

-- ========================================
-- BUTTONS
-- ========================================

-- Simple button with setText
local button1 = tab:addButton({
    text = "Simple Button",
    callback = function()
        print("Simple button clicked!")
    end
})

-- Button that changes its own text when clicked (SAFE way)
-- Create button WITHOUT callback first
local button2 = tab:addButton({
    text = "Click to Change Text"
})

-- Then connect the callback AFTER the variable is assigned
button2.element.MouseButton1Click:Connect(function()
    button2.setText("Text Changed!")
end)

-- Button with external setText after delay
local button3 = tab:addButton({
    text = "Wait 5 seconds...",
    callback = function()
        print("Button 3 clicked!")
    end
})

task.spawn(function()
    task.wait(5)
    button3.setText("5 seconds passed!")
end)

-- ========================================
-- TOGGLES
-- ========================================

local toggle1 = tab:addToggle({
    text = "Enable Feature",
    default = false,
    callback = function(state)
        print("Feature enabled:", state)
    end
})

-- Safely change toggle text after creation
task.spawn(function()
    task.wait(1)
    toggle1.setText("Feature Toggle (Updated)")
end)

-- ========================================
-- ACTION TOGGLES
-- ========================================

local action1 = tab:addActionToggle({
    text = "Execute Action",
    callback = function()
        print("Action executed!")
    end
})

-- Change label immediately (safe)
task.spawn(function()
    action1.setText("Run Command")
end)

-- ========================================
-- SLIDERS - Basic with Decimals
-- ========================================

local slider1 = tab:addSlider({
    text = "Speed",
    min = 0,
    max = 1,
    default = 0.5,
    decimals = 2,  -- 2 decimal places
    suffix = "x",
    callback = function(value)
        print("Speed changed to:", value)
    end
})

-- ========================================
-- SLIDERS - With Custom Labels
-- ========================================

local slider2 = tab:addSlider({
    text = "Delay",
    min = 0.05,
    max = 2,
    default = 1,
    decimals = 2,
    suffix = "s",
    labels = {
        {0.05, "Very Fast"},
        {0.3, "Fast"},
        {0.8, "Normal"},
        {1.3, "Slow"},
        {1.8, "Very Slow"}
    },
    callback = function(value)
        print("Delay:", value)
    end
})
-- Output example: "Delay: Very Fast (0.05s)" or "Delay: Normal (1.00s)"

local slider3 = tab:addSlider({
    text = "Cooldown",
    min = 0.1,
    max = 10,
    default = 1,
    decimals = 1,
    suffix = "s",
    labels = {
        {0.1, "Instant"},
        {1, "Quick"},
        {3, "Medium"},
        {6, "Long"},
        {9, "Very Long"}
    },
    callback = function(value)
        print("Cooldown:", value)
    end
})

local slider4 = tab:addSlider({
    text = "Graphics Quality",
    min = 1,
    max = 5,
    default = 3,
    decimals = 0,  -- Integers only
    labels = {
        {1, "Low"},
        {2, "Medium"},
        {3, "High"},
        {4, "Ultra"},
        {5, "Maximum"}
    },
    callback = function(value)
        print("Graphics quality:", value)
    end
})

-- ========================================
-- SLIDERS - Regular (No Labels)
-- ========================================

local slider5 = tab:addSlider({
    text = "Volume",
    min = 0,
    max = 100,
    default = 50,
    decimals = 0,
    suffix = "%",
    callback = function(value)
        print("Volume:", value)
    end
})

local slider6 = tab:addSlider({
    text = "Price",
    min = 0,
    max = 999.99,
    default = 19.99,
    decimals = 2,
    suffix = " USD",
    callback = function(value)
        print("Price:", value)
    end
})

-- ========================================
-- DROPDOWNS
-- ========================================

local dropdown1 = tab:addDropdown({
    label = "Select Mode",
    options = {"Easy", "Normal", "Hard"},
    default = "Normal",
    callback = function(option)
        print("Selected mode:", option)
    end
})

task.spawn(function()
    task.wait(2)
    dropdown1.setText("Difficulty Level")
end)

local dropdown2 = tab:addDropdown({
    label = "Weapon Type",
    options = {"Sword", "Axe", "Bow", "Staff"},
    default = "Sword",
    callback = function(option)
        print("Selected weapon:", option)
    end
})

-- ========================================
-- TYPE SWITCHERS
-- ========================================

local switcher1 = tab:addTypeSwitcher({
    types = {"Pokeball", "Greatball", "Ultraball"},
    default = 1,
    callback = function(type, index)
        print("Switched to:", type, "at index", index)
    end
})

local switcher2 = tab:addTypeSwitcher({
    types = {"Red", "Blue", "Green"},
    default = 2,
    callback = function(type, index)
        print("Color:", type)
    end
})

-- ========================================
-- LABELS & INFO CONTAINERS
-- ========================================

local label1 = tab:addLabel({
    text = "This is a label"
})

task.spawn(function()
    task.wait(3)
    label1.setText("Label text updated!")
end)

local info1 = tab:addInfoContainer({
    text = "This is an info container.\nIt can display multiple lines of text.\nUseful for instructions or status.",
    height = 80
})

task.spawn(function()
    task.wait(4)
    info1.setText("Info updated!\nNew information displayed here.")
end)

-- ========================================
-- TEXTBOXES
-- ========================================

local textbox1 = tab:addTextbox({
    placeholder = "Enter your name...",
    default = "",
    callback = function(text, enterPressed)
        print("Text entered:", text, "| Enter pressed:", enterPressed)
    end
})

print("✅ UI Library loaded successfully with all features!")
print("Press H to toggle the UI")
